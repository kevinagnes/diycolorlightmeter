
///////////////////////////////////////////////////
// INCLUDE||DEFINE SECTION
#include <SPI.h>                        // Library necessary                      
#include <Wire.h>                       // Library necessary
#include <Adafruit_GFX.h>               // Library for Graphics||Bitmaps||Fonts
#include <Adafruit_SSD1306.h>           // Library for (not only) the 128x64 OLED display
#include <Adafruit_Sensor.h>            // Library necessary
#include "Adafruit_TCS34725.h"
#define SCL_PORT PORTC
#define SCL_PIN 3
#define SDA_PORT PORTC
#define SDA_PIN 2
#include <SoftI2CMaster.h>
#include "Adafruit_TSL2591Soft.h"
#include <EEPROM.h>                     // Library for using the EEPROM memory
#define OLED_RESET 8                    // OLED reset pin set to digitalPin 4 // I2C ONLY
Adafruit_SSD1306 display(OLED_RESET);   // I2C ONLY
///// Constants for calibration
#define TCS34725_R_Coef 0.136
#define TCS34725_G_Coef 1.000
#define TCS34725_B_Coef -0.444
#define TCS34725_GA 1.0
#define TCS34725_DF 310.0
#define TCS34725_CT_Coef 3810.0
#define TCS34725_CT_Offset 1391.0
#define C_const 129                     // Calibration constant for the TSL2591
#define DomeMultiplier 2.17             // Multiplier when using a white translucid Dome covering the TSL2591
//#define DomeSum                       // More test required but the difference in first test was around 100K
///////////////////////////////////////////////////
// INT||FLOAT||STRING||BOOLEAN
uint8_t Rp = 2;                         // Metering button pin
uint8_t Bn1p = 3;                       // + increment button pin
uint8_t Bn2p = 4;                       // - increment button pin
uint8_t Tdisplay;                       // State of shutter speed value display (fractional, seconds, minutes)
uint8_t Tfr;
uint8_t taddr = 0;                      // Address to write tcm to EEPROM
uint8_t Am = 15;                        // Starts Photo Mode with f2.8
uint8_t tca;                            // Shutter angle selector
uint8_t Saddr = 1;                      // Address to write Sv to EEPROM
uint8_t Buzzer = 9;                     // Buzzer for Button confirmation
uint8_t x_vmode = 0;                    // X Position - cine/video/...
uint8_t y_vmode = 32;                   // Y Position - cine/video/...
uint8_t Astring;
uint8_t t;
uint8_t ndStop = 0;


///////////////////////////////////////////////////
float lux;                              // Lux value from TSL2591
float ct;                               // Color Temp value from TCS34725
float ISOND;
//float EV;                             // EV value for PhotoMode
float Tmin;                             // Time in minutes
///////////////////////////////////////////////////
boolean Bn1;                            // + increment button state
boolean Bn2;                            // - increment button state
boolean R;                              // Metering button state
boolean ISOmode = 0;                    // ISO mode state
boolean Shuttermode = 0;                // Shutter mode state for Cine or Photo
boolean save = 0;                       // Save to EEPROM state
boolean freeze = 0;                     // Freezes the Shutter (CINE) || Aperture (Photo)
boolean State = 0;                      // Activate Shuttermode Animation
boolean Anglemode = 0 ;                 // Activate shutter angle mode at 24fps
boolean needHigh = 0 ;                  // if needHigh = 1 , High gain is applied (428x gain) and display "Hi"
boolean Overflow = 0;                   // Sensor got Saturated and Display "Overflow"
boolean NDmode = 0;
///////////////////////////////////////////////////
// ARRAYS for Photo and Cine values
int S [] = {100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600}; //ISO array
float A [] = {0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.4, 1.6, 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5.0, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22, 25, 29, 32, 36, 40, 45, 51, 57, 64, 72, 80, 90}; // Aperture array
int t_cine [] = {8, 16, 24, 25, 30, 48, 50, 60, 96, 100, 120}; // fps Cine/video array obs: making double time at the equation
int t_angle [] = {360, 270, 180, 172, 144, 90, 72, 45}; // shutter angle @ 24fps
int ND[] =     {0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48}; // eg.: 1) 0.3 ND = -1 stop = 2^2 = 4; 2) 0.9 ND = -3 stop = 2^3 = 16;
///////////////////////////////////////////////////
// EEPROM for memory recording
uint8_t Sm =          EEPROM.read(1);
uint8_t tcm =         EEPROM.read(0);
///////////////////////////////////////////////////
// TCS 34725
class ColorSensor {
  public:

    void getColorTemp();
    uint16_t r, g, b, c, ir;
    uint16_t ct, lux, r_comp, g_comp, b_comp;
    float cpl;
};

void ColorSensor::getColorTemp() {


  Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_101MS, TCS34725_GAIN_1X);

  tcs.getRawData(&r, &g, &b, &c);
  //lux = tcs.calculateLux(r, g, b);
  // DN40 calculations
  ir = (r + g + b > c) ? (r + g + b - c) / 2 : 0;
  r_comp = r - ir;
  g_comp = g - ir;
  b_comp = b - ir;
  //c_comp = c - ir;

  ////////cpl = (700) / (TCS34725_GA * TCS34725_DF);
  ////////lux = (TCS34725_R_Coef * float(r_comp) + TCS34725_G_Coef * float(g_comp) + TCS34725_B_Coef * float(b_comp)) / cpl;
  ct = TCS34725_CT_Coef * float(b_comp) / float(r_comp) + TCS34725_CT_Offset;
  
  // Kelvin compensation using Formatt-Hightech PROSTOP IRND 0.9 & 2.1
  // if (ndStop == 2) {ct = ct + 100;} if (ndStop == 7) {ct = ct + 180;} // BASE 2700K 60W Incandecent bulb
  // Need more testing in Daylight, Fluorescent light and High temperature dawn


}
ColorSensor rgb_sensor;
///////////////////////////////////////////////////
// SETUP
///////////////////////////////////////////////////
void setup() {
  // PINMODE
  pinMode(Bn1p, INPUT_PULLUP);
  pinMode(Bn2p, INPUT_PULLUP);
  pinMode(Rp, INPUT_PULLUP);
 // pinMode(Buzzer, OUTPUT);                    // not necessary
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  display.begin(SSD1306_SWITCHCAPVCC, 0x3D);  //Initialize with the I2C addr 0x3D (for the 128x64 OLED)
  display.clearDisplay();                     // Clean display before Intro Animation
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  introanimation();                           // intro ANIMATION
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  // IF NO MEMORY WAS RECORDED BEFORE, START WITH THIS VALUES otherwise it will read "255"
  if (tcm > (sizeof(t_cine) / sizeof(int) - 1))
  {
    tcm = 2;
  }
  //if (Am > (sizeof(A)/sizeof(float)-1))
  //{Am = 4;}
  if (Sm > (sizeof(S) / sizeof(int) - 1))
  {
    Sm = 2;
  }

  lux = getLux();   // MAIN command to get a new exposure
  rgb_sensor.getColorTemp(); // MAIN command to get a new WB Value

}
//////////////////////////////////////////////////////////////////////////////////////////////////////
void readAll() {
  Bn1 = digitalRead(Bn1p);
  Bn2 = digitalRead(Bn2p);
  R = digitalRead(Rp);
}

void loop() {

  readAll();
  
  //IF BUTTON (-) AND (M) ARE BOTH PRESSED, SAVE EEPROM DATA AND FREEZES THE SETTINGS
  if (Bn1 == 0 & R == 0)
  {
    save = 1;
    freeze = 1;
  }
  while (Bn1 == 0 & R == 0)
  {
    delay(100);
    readAll();
  }

  if (save == 1)
  {
    if (tcm == 2) {
      Anglemode = 1;
      tca = 2;
    } else {
      Anglemode = 0;
    }
    EEPROM.write(taddr, tcm); //saving settings
    EEPROM.write(Saddr, Sm);  //saving settings
    //tone(Buzzer, 800, 50);    //SOUNDDD
    Astring = 0;
    modeWindow();
    save = 0;
    Bn1 = 1;
    Bn2 = 1;
  }

  if (Anglemode == 1)
  {
    //READ BUTTON (+) AND INCREMENT ANGLE VALUE
    if (Bn1 == 0)
    {
      if (tca >= (sizeof(t_angle) / sizeof(int) - 1))
      {
        tca = 0;
      }
      else {
        tca = tca + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT ANGLE VALUE
    if (Bn2 == 0)
    {
      if (tca == 0) {
        tca = (sizeof(t_angle) / sizeof(int) - 1);
      }
      else {
        tca = tca - 1;
      }
    }
  }

  if (freeze == 0)
  {
    //READ BUTTON (+) AND INCREMENT SHUTTER VALUE
    if (Bn1 == 0)
    {
      if (tcm >= (sizeof(t_cine) / sizeof(int) - 1))
      {
        tcm = 0;
      }
      else {
        tcm = tcm + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT SHUTTER VALUE
    if (Bn2 == 0)
    {
      if (tcm == 0) {
        tcm = (sizeof(t_cine) / sizeof(int) - 1);
      }
      else {
        tcm = tcm - 1;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF BUTTON (-) AND (M) ARE BOTH PRESSED, CHANGE SHUTTER MODE
  if (Bn2 == 0 & R == 0)
  {
    State = 1 - State;
    modeWindow();
    delay(10); //100
  }
  if (State == 1)
  {
    Shuttermode = 1; /*Photo Mode (Aperture Priority)*/
  }
  else
  {
    Shuttermode = 0; /*Cine Mode (Aperture Priority)*/
  }

  //READ BUTTON (+) AND INCREMENT APERTURE VALUE
  if (freeze == 0)
  {
    if (Bn1 == 0)
    {
      if (Am >= (sizeof(A) / sizeof(float) - 1))
      {
        Am = 0;
      }
      else {
        Am = Am + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT APERTURE VALUE
    if (Bn2 == 0)
    {
      if (Am == 0)
      {
        Am = (sizeof(A) / sizeof(float) - 1);
      }
      else
      {
        Am = Am - 1;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF BUTTON (-) AND (+) ARE BOTH PRESSED, ENTER ISO/ND MODE

  if (Bn1 == 0 & Bn2 == 0)
  {
    ISOmode = 1;
  }
  while (Bn1 == 0 & Bn2 == 0)
  {
    delay(100);
    readAll();
  }
  
  if (ISOmode == 1)
  {
    Astring = 2;
    modeWindow();
    save = 0;
    //Bn1 = 1;
    //Bn2 = 1;
  }
  while (ISOmode == 1)
  {
    readAll();
    
    if (Bn1 == 0 & Bn2 == 0)
    {
      //tone(Buzzer, 400, 50); //SOUNDDD
      ISOmode = 0;
      NDmode = 0;
      freeze = 0;
      Anglemode = 0;
      Astring = 1;
      modeWindow();
    }

    if (R == 0) {

    NDmode = 1;
    //R = 0;
  }
 
  while (NDmode == 1)
  //
  {
    readAll();
    
    if (R == 0)
    {
      NDmode = 0;
    }

    //READ BUTTON (+) AND INCREMENT ND VALUE
    if (Bn1 == 0) 
    {
     if (ndStop >= (sizeof(ND) / sizeof(int) - 1))
      {
        ndStop = 0;
      }
      else {
        ndStop = ndStop + 1;
      } 
    }
    //READ BUTTON (-) AND INCREMENT ND VALUE
     if (Bn2 == 0)
    { 
      if (ndStop == 0)
      {
        ndStop = (sizeof(ND) / sizeof(int) - 1);
      }
      else {
        ndStop = ndStop - 1;
      }
    }
    
    refresh(); // While in NDmode, call function for refreshing the Display
    buttonDelay();
  }

    //READ BUTTON (+) AND INCREMENT SENSITIVITY VALUE
    if (Bn1 == 0)
    { if (Sm >= (sizeof(S) / sizeof(int) - 1))
      {
        Sm = 0;
      }
      else {
        Sm = Sm + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT SENSITIVITY VALUE
    if (Bn2 == 0)
    { if (Sm == 0)
      {
        Sm = (sizeof(S) / sizeof(int) - 1);
      }
      else {
        Sm = Sm - 1;
      }
    }

    refresh(); // While in ISO Mode, call function for refreshing the Display
    buttonDelay();
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  // REFRESH AND BUTTON DEBUG

  refresh(); // While Shuttermode = 0 or 1, call function for refreshing the Display

  buttonDelay();
  
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF (M) BUTTON IS PRESSED, GET A NEW LUX VALUE and COLOR TEMP VALUE
  if (R == 0)
  {
    lux = getLux();
    rgb_sensor.getColorTemp();
    //tone(Buzzer, 3000, 100);
  }

  if (Overflow == 1)
  {delay(10); getLux();}

} // END OF LOOP \\

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////   FUNCTIONS   ////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
float getLux()
{
  Adafruit_TSL2591 tsl = Adafruit_TSL2591(2591);

  sensor_t sensor;
  tsl.getSensor(&sensor);

  if (needHigh == 1) {
  tsl.setGain(TSL2591_GAIN_HIGH);   // 428x gain
  }
  else {
  tsl.setGain(TSL2591_GAIN_LOW);    /* 1x gain (bright light)*/
  }
  tsl.setTiming(TSL2591_INTEGRATIONTIME_200MS); /*shortest integration time (bright light)*/

  tsl.begin();

  sensors_event_t event;
  tsl.getEvent(&event);
  float lux = event.light;
  if   ((event.light == 0) |              // When sensor gets saturated (normally in transition between Gain)
       (event.light > 4294966000.0) |     // Lux value is restored to 201 for a effective change in Gain (from 428x to 1x)
       (event.light <-4294966000.0))      // Overflow is displayed indicating that this value is not correct
       {lux = 201; Overflow = 1;} 
  else {Overflow = 0;}
    
  lux = lux * DomeMultiplier;             // DomeMultiplier = 2.17 (calibration)
  if (lux < 40) {needHigh = 1;}           // ~ 1 +1/3 OFFSET (*0.26 in lux calibration)
  if (lux > 200) {needHigh = 0;}          // Turns off High gain
  if (needHigh == 1) {lux = lux*.26;}     // OFFSET corrected
  
  return lux;
  
}

void buttonDelay() {
   //DELAYS FOR BUTTON HOLD
    while (Bn1 == 0)
    {
      delay(10);
      Bn1 = digitalRead(Bn1p);
    }
    while (Bn2 == 0)
    {
      delay(10);
      Bn2 = digitalRead(Bn2p);
    }
}

void refresh()  //This function gives a new calculation based on the last illuminance value, and refreshes the display.

{
  if (Shuttermode == 0)
    //////////////////////////// CINE MODE //////////////////////
  {
    int intCinefps = t_cine[tcm];                // FPS
    float t_final;                               // shutter speed/ shutter angle
    String Ev;                                   // F stop
    int Evplus;                                  // Thirds of stop
    String Fplus[] {F("+1/3") , F("+2/3")};      // String Array of Thirds of stop
    // Formula
    if (Anglemode == 1) {
      t_final = pow((8640 / t_angle[tca]), -1);
    }
    else {
      t_final = pow(((intCinefps) * 2), -1); // Shutter Speed // Formula because intCinefps is frames per second
    }
    if (ndStop > 0) { ISOND = S[Sm]/(pow(2,ndStop)); }   // ND filter altering the ISO
    else { ISOND = S[Sm]; }
    
    float N = sqrt((lux * ISOND * t_final) / C_const);       // float APERTURE 
    //float Fc = lux * 0.0929;                           // FootCandle

    // Translation for printing the Display
    if ((N >= 0.5) && (N < 0.8)) {
      Ev = F("0.7");
      Evplus = 2;
    }
    if ((N >= 0.8) && (N < 0.9)) {
      Ev = F("0.7");
      Evplus = 0;
    }
    if ((N >= 0.9) && (N < 1))   {
      Ev = F("0.7");
      Evplus = 1;
    }
    if ((N >= 1.0) && (N < 1.1)) {
      Ev = F("1");
      Evplus = 2;
    }
    if ((N >= 1.1) && (N < 1.2)) {
      Ev = F("1");
      Evplus = 0;
    }
    if ((N >= 1.2) && (N < 1.4)) {
      Ev = F("1");
      Evplus = 1;
    }
    if ((N >= 1.4) && (N < 1.6)) {
      Ev = F("1.4");
      Evplus = 2;
    }
    if ((N >= 1.6) && (N < 1.8)) {
      Ev = F("1.4");
      Evplus = 0;
    }
    if ((N >= 1.8) && (N < 2))   {
      Ev = F("1.4");
      Evplus = 1;
    }
    if ((N >= 2.0) && (N < 2.2)) {
      Ev = F("2");
      Evplus = 2;
    }
    if ((N >= 2.2) && (N < 2.5)) {
      Ev = F("2");
      Evplus = 0;
    }
    if ((N >= 2.5) && (N < 2.8)) {
      Ev = F("2");
      Evplus = 1;
    }
    if ((N >= 2.8) && (N < 3.2)) {
      Ev = F("2.8");
      Evplus = 2;
    }
    if ((N >= 3.2) && (N < 3.5)) {
      Ev = F("2.8");
      Evplus = 0;
    }
    if ((N >= 3.5) && (N < 4))   {
      Ev = F("2.8");
      Evplus = 1;
    }
    if ((N >= 4.0) && (N < 4.5)) {
      Ev = F("4");
      Evplus = 2;
    }
    if ((N >= 4.5) && (N < 5.0)) {
      Ev = F("4");
      Evplus = 0;
    }
    if ((N >= 5.0) && (N < 5.6)) {
      Ev = F("4");
      Evplus = 1;
    }
    if ((N >= 5.6) && (N < 6.3)) {
      Ev = F("5.6");
      Evplus = 2;
    }
    if ((N >= 6.3) && (N < 7.1)) {
      Ev = F("5.6");
      Evplus = 0;
    }
    if ((N >= 7.1) && (N < 8))   {
      Ev = F("5.6");
      Evplus = 1;
    }
    if ((N >= 8.0) && (N < 9.0)) {
      Ev = F("8");
      Evplus = 2;
    }
    if ((N >= 9)   && (N < 10))  {
      Ev = F("8");
      Evplus = 0;
    }
    if ((N >= 10)  && (N < 11))  {
      Ev = F("8");
      Evplus = 1;
    }
    if ((N >= 11)  && (N < 13))  {
      Ev = F("11");
      Evplus = 2;
    }
    if ((N >= 13)  && (N < 14))  {
      Ev = F("11");
      Evplus = 0;
    }
    if ((N >= 14)  && (N < 16))  {
      Ev = F("11");
      Evplus = 1;
    }
    if ((N >= 16)  && (N < 18))  {
      Ev = F("16");
      Evplus = 2;
    }
    if ((N >= 18)  && (N < 20))  {
      Ev = F("16");
      Evplus = 0;
    }
    if ((N >= 20)  && (N < 22))  {
      Ev = F("16");
      Evplus = 1;
    }
    if ((N >= 22)  && (N < 25))  {
      Ev = F("22");
      Evplus = 2;
    }
    if ((N >= 25)  && (N < 29))  {
      Ev = F("22");
      Evplus = 0;
    }
    if ((N >= 29)  && (N < 32))  {
      Ev = F("22");
      Evplus = 1;
    }
    if ((N >= 32)  && (N < 36))  {
      Ev = F("32");
      Evplus = 2;
    }
    if ((N >= 36)  && (N < 40))  {
      Ev = F("32");
      Evplus = 0;
    }
    if ((N >= 40)  && (N < 45))  {
      Ev = F("32");
      Evplus = 1;
    }
    if ((N >= 45)  && (N < 51))  {
      Ev = F("45");
      Evplus = 2;
    }
    if ((N >= 51)  && (N < 57))  {
      Ev = F("45");
      Evplus = 0;
    }
    if ((N >= 57)  && (N < 64))  {
      Ev = F("45");
      Evplus = 1;
    }
    if ((N >= 64)  && (N < 72))  {
      Ev = F("64");
      Evplus = 2;
    }
    if ((N >= 72)  && (N < 80))  {
      Ev = F("64");
      Evplus = 0;
    }
    if ((N >= 80)  && (N < 90))  {
      Ev = F("64");
      Evplus = 1;
    } 
    // DISPLAY PRINTING ////////////////////////////////////////
    ///////////////////////////// F STOP AND THIRDS ////////////
    display.setTextColor(WHITE);
    display.setCursor(0, 6);
    if ((N < 0.5) || (N > 90))
    { outOfrange();}
    else
    { // ALL OTHER VALUES
      display.setTextSize(1);
      display.print(F("f/ "));
      display.setTextSize(3);
      //display.setTextColor(WHITE);
      display.print(Ev);
      if (Evplus < 2) {
        display.setTextSize(2);
        display.println(Fplus[Evplus]);
      }
    }
    display.setTextSize(0);
    ///////////////////////////// CINE MODES FPS SHUTTER SPEED /
    if (intCinefps < 24) {
      display.setCursor(x_vmode, y_vmode);
      //display.setTextColor(WHITE);
      display.println(F("super8"));
    }
    ////////////////////////
    if (intCinefps == 24) {
      display.setCursor(x_vmode, y_vmode);
      //display.setTextColor(WHITE);
      display.println(F("cine"));
    }
    ////////////////////////
    if (intCinefps > 30) {
      display.setCursor(x_vmode, y_vmode);
      //display.setTextColor(WHITE);
      display.println(F("slow"));
    }
    ////////////////////////
    if (intCinefps == 25) {
      display.setCursor(x_vmode, y_vmode);
      //display.setTextColor(WHITE);
      display.println(F("video PAL"));
    }
    ////////////////////////
    if (intCinefps == 30) {
      display.setCursor(x_vmode, y_vmode);
      //display.setTextColor(WHITE);
      display.println(F("video NTSC"));
    }
    ////////////////////////
    display.setCursor(0, 42);
    //display.setTextColor(WHITE);
    if (Anglemode == 1) {
    display.print(F("1/")); 
    display.println(8640/(t_angle[tca])); 
    }
    else {
    display.print( intCinefps, 1);
    //display.setTextColor(WHITE);
    display.println(F("fps"));
    }
    display.setCursor(0, 52);
    //display.setTextColor(WHITE);
    if (Anglemode == 1) {
      display.print(t_angle[tca]);
      display.println(F(" angle"));
    }
    if (Anglemode == 0) {
      display.print(F("1/"));
      display.println(intCinefps * 2);
    }
    //////////////////////// 
    display.drawLine(73, 24, 73, 62, WHITE); // LINE DIVISOR
    display.setTextSize(1);
    displayHighGain();
    ////////////////////////
    display.setCursor(75, 24);
    display.print(F("ISO"));
    display.println(S[Sm]);      // ISO
    ////////////////////////
    display.setCursor(75, 34);
    if (Overflow == 1) {display.println(F("Overflow"));}
    else {
    display.print(F("f/"));
    display.println(N);}         // APERTURE FULL VALUE
    ////////////////////////
    display.setCursor(75, 44);
    display.print(rgb_sensor.ct);
    display.println(F("K"));     // KELVINS
    ////////////////////////
    display.setCursor(75, 54);
    display.print(F("ND "));
    display.println(ND[ndStop]); // ND filtration
    /* display.setCursor(75, 54);
    display.print(Fc);
    display.println(F("Fc")); // FOOTCANDLES */
    ////////////////////////
    t=0;
    refreshtiming();

  }

  else
    //////////////////////////// PHOTO MODE //////////////////////
  { 
    if (ndStop > 0) { ISOND = S[Sm]/(pow(2,ndStop)); }
    else { ISOND = S[Sm]; }
    float T = pow(A[Am], 2) * C_const / (lux * ISOND); //T = exposure time, in seconds

    if (T >= 60)
    {
      Tdisplay = 0;  //Exposure is now in minutes
      Tmin = T / 60;
    }
    else if (T < 0.75)
    {
      Tdisplay = 1;  //Exposure is now in fractional form
      if (T < 0.000125) {
        Tdisplay = 3;
      }
      if ((T <= 0.000188) && (T > 0.000125)) {
        Tfr = 8000;
      }
      if ((T <= 0.000375) && (T > 0.000188)) {
        Tfr = 4000;
      }
      if ((T <= 0.00075) && (T > 0.000375)) {
        Tfr = 2000;
      }
      if ((T <= 0.0015) && (T > 0.00075)) {
        Tfr = 1000;
      }
      if ((T <= 0.003) && (T > 0.0015)) {
        Tfr = 500;
      }
      if ((T <= 0.006) && (T > 0.003)) {
        Tfr = 250;
      }
      if ((T <= 0.012333) && (T > 0.006)) {
        Tfr = 125;
      }
      if ((T <= 0.025) && (T > 0.012333)) {
        Tfr = 60;
      }
      if ((T <= 0.05) && (T > 0.025)) {
        Tfr = 30;
      }
      if ((T <= 0.095833) && (T > 0.05)) {
        Tfr = 15;
      }
      if ((T <= 0.1875) && (T > 0.095833)) {
        Tfr = 8;
      }
      if ((T <= 0.375) && (T > 0.1875)) {
        Tfr = 4;
      }
      if ((T <= 0.75) && (T > 0.375)) {
        Tfr = 2;
      }
    }
    else if ((T >= 0.75) && (T < 60))
    {
      Tdisplay = 2;  //Exposure in seconds
    }
    if (lux == 0)    //This happens if the sensor is overloaded or senses no light.
    {
      Tdisplay = 3;
    }

    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 6);
    display.print(F("f/ "));
    display.setTextSize(2);
    display.println(A[Am], 1);
    display.setCursor(0, 42);
    display.setTextSize(3);

    if (Tdisplay == 0)
    {
      display.print(Tmin, 1);
      display.println(F("m"));
    }
    else if (Tdisplay == 1)
    {
      display.print(F("1/"));
      display.println(Tfr);
    }
    else if (Tdisplay == 2)
    {
      display.print(T, 1);
      display.println(F("s"));
    }
    else if (Tdisplay == 3)
    {
      outOfrange();
    }

    display.drawLine(73, 6, 73, 35, WHITE);
    display.setTextSize(1);
    displayHighGain();
    display.setCursor(76, 6);
    display.print(F("ISO"));
    display.println(S[Sm]);
    display.setCursor(76, 17);
    display.print(rgb_sensor.ct);
    display.println(F("K"));
    display.setCursor(76, 29);
    display.print(lux, 1);
    display.println(F("Lx"));
    display.setCursor(16, 29);
    if (Overflow == 1) {display.println(F("Overflow"));}
    else {display.print(F("ND "));display.print(ND[ndStop]);} // ND filtration
    t=0;
    refreshtiming();
  }
}

void outOfrange() {
      display.setTextSize(1);
      display.print("OUT OF ");
      display.setTextSize(2);
      display.println(F("RANGE!"));
}

void displayHighGain(){
  if (needHigh == 1) {
    display.drawLine(0, 18, 12, 18, WHITE); // LINE DIVISOR
    display.drawLine(0, 28, 12, 28, WHITE); // LINE DIVISOR
    display.drawLine(12, 18, 12, 28, WHITE); // LINE DIVISOR
    display.setCursor(0,20);  
    display.println(F("Hi"));}
}
 
void refreshtiming() {
    int timing[] = {0,120,500};
    display.display();
    delay(timing[t]);
    display.clearDisplay();
}

void modeWindow() {
    String modeA[] = {F("Saved"), F("Selected"), F("ISO Set"), F("PHOTO Mode"), F("CINE Mode"), F("Freezed"), F("Unfreezed"), F(""), F("Aperture Priority"), F("Shutter Priority")};
    if ((State == 1) && (Shuttermode == 0))
    {Astring = 3;}
    if ((State == 0) && (Shuttermode == 1))
    {Astring = 4;}
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(5, 20);
    display.println(modeA[Astring]);
    display.setCursor(5, 40);
    display.setTextSize(1);
    display.println(modeA[Astring+5]);
    t=2;
    refreshtiming();  
}

//BITMAP IMAGES FOR INTRO ANIMATION
const unsigned char PROGMEM a5 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
  0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x7C, 0xFC, 0x78, 0x7C, 0x03, 0xF0, 0xC6, 0x30, 0xCC, 0x66,
  0x01, 0xC0, 0xC6, 0x31, 0x86, 0x66, 0x01, 0xC0, 0x70, 0x31, 0x86, 0x66, 0x01, 0xC0, 0x0C, 0x31,
  0x86, 0x7C, 0x01, 0xC0, 0xC6, 0x31, 0x86, 0x60, 0x01, 0x80, 0xC6, 0x30, 0xCC, 0x60, 0x01, 0x80,
  0x7C, 0x30, 0x78, 0x60, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x42, 0x2C, 0x20,
  0x30, 0x78, 0x45, 0x30, 0x2C, 0x20, 0x30, 0x78,
};
const unsigned char PROGMEM a4 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF6,
  0x00, 0x00, 0x00, 0x00, 0x3F, 0xF7, 0x80, 0x00, 0x00, 0x00, 0x3F, 0xF7, 0xC0, 0x00, 0x00, 0x01,
  0x9F, 0xF7, 0xF0, 0x00, 0x00, 0x03, 0xCF, 0xF7, 0xF0, 0x00, 0x00, 0x07, 0xF7, 0xF7, 0xF8, 0x00,
  0x00, 0x07, 0xF3, 0xF7, 0xFA, 0x00, 0x00, 0x0F, 0xF9, 0xF7, 0xF7, 0x00, 0x00, 0x0F, 0xFE, 0xF7,
  0xEF, 0x00, 0x00, 0x1F, 0xFE, 0x77, 0xDF, 0x00, 0x00, 0x1F, 0xFF, 0xB7, 0xBF, 0x00, 0x00, 0x00,
  0x00, 0x07, 0x7F, 0x00, 0x00, 0x1F, 0xFC, 0x04, 0xFF, 0x00, 0x00, 0x1F, 0xF8, 0x01, 0xFF, 0x00,
  0x00, 0x1F, 0xF0, 0x03, 0xFF, 0x00, 0x00, 0x1F, 0xE8, 0x07, 0xFE, 0x00, 0x00, 0x1F, 0xDA, 0x07,
  0xFC, 0x00, 0x00, 0x1F, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x7B, 0x7F, 0xFE, 0x00, 0x00, 0x0E,
  0xFB, 0xBF, 0xFE, 0x00, 0x00, 0x09, 0xFB, 0xDF, 0xFC, 0x00, 0x00, 0x03, 0xFB, 0xEF, 0xF8, 0x00,
  0x00, 0x07, 0xFB, 0xF7, 0xF8, 0x00, 0x00, 0x03, 0xFB, 0xFB, 0xF0, 0x00, 0x00, 0x01, 0xFB, 0xFD,
  0xC0, 0x00, 0x00, 0x00, 0xFB, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x1B, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x2C, 0x20, 0x30,
  0x78, 0x39, 0x46, 0x2C, 0x20, 0x30, 0x78, 0x30,
};
const unsigned char PROGMEM a3 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF8,
  0x80, 0x00, 0x00, 0x00, 0x1B, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x7D, 0xFE, 0xE0, 0x00, 0x00, 0x00,
  0xFC, 0xFE, 0xF0, 0x00, 0x00, 0x01, 0xFE, 0x7E, 0xF8, 0x00, 0x00, 0x03, 0xFF, 0xBE, 0xFC, 0x00,
  0x00, 0x07, 0xFF, 0xDE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xFE, 0x00, 0x00, 0x0F, 0xF0, 0x06,
  0xFE, 0x00, 0x00, 0x0F, 0xF0, 0x02, 0xFE, 0x00, 0x00, 0x1F, 0xE0, 0x00, 0xFC, 0x00, 0x00, 0x1F,
  0xC0, 0x00, 0xF9, 0x00, 0x00, 0x1F, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x1E, 0x40, 0x00, 0xE7, 0x00,
  0x00, 0x1C, 0xC0, 0x00, 0xCF, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x9F, 0x00, 0x00, 0x11, 0xC0, 0x00,
  0x3F, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x7F, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0xFE, 0x00, 0x00, 0x0F,
  0xD0, 0x01, 0xFC, 0x00, 0x00, 0x0F, 0xD8, 0x03, 0xFC, 0x00, 0x00, 0x07, 0xDC, 0x00, 0x00, 0x00,
  0x00, 0x07, 0xDC, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xDE, 0x7F, 0xF0, 0x00, 0x00, 0x01, 0xDF, 0x3F,
  0xE0, 0x00, 0x00, 0x00, 0xDF, 0x9F, 0xC0, 0x00, 0x00, 0x00, 0x1F, 0xCF, 0x00, 0x00, 0x00, 0x00,
  0x1F, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x20, 0x30, 0x78,
  0x30, 0x37, 0x2C, 0x20, 0x30, 0x78, 0x42, 0x43,
};
const unsigned char PROGMEM a2 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x78,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x9F, 0x80, 0x00, 0x00, 0x00,
  0xFF, 0xCF, 0x80, 0x00, 0x00, 0x01, 0xFF, 0xE7, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xB0, 0x00,
  0x00, 0x07, 0xF0, 0x01, 0xB8, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0xBC, 0x00, 0x00, 0x0F, 0xC0, 0x00,
  0xBE, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x3F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x1C,
  0x00, 0x00, 0x3F, 0x00, 0x00, 0x19, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x13, 0x00, 0x00, 0x38, 0x00,
  0x00, 0x07, 0x00, 0x00, 0x33, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x27, 0x00, 0x00, 0x1F, 0x00, 0x00,
  0x0F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x0F,
  0x40, 0x00, 0x7C, 0x00, 0x00, 0x0F, 0x60, 0x00, 0xFC, 0x00, 0x00, 0x07, 0x70, 0x01, 0xF8, 0x00,
  0x00, 0x03, 0x78, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7D, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x7C, 0xFF,
  0xE0, 0x00, 0x00, 0x00, 0x7E, 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00,
  0x0F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x07, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x30, 0x30,
  0x2C, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2C, 0x20,
};
const unsigned char PROGMEM a1 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xBC,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xEF, 0x80, 0x00, 0x00, 0x00,
  0x3F, 0xF7, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x03, 0xE0, 0x00, 0x00, 0x03, 0xC0, 0x01, 0xE0, 0x00,
  0x00, 0x07, 0xC0, 0x00, 0xE8, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x6C, 0x00, 0x00, 0x0F, 0x80, 0x00,
  0x2E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x12,
  0x00, 0x00, 0x0F, 0x00, 0x00, 0x06, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0F, 0x00,
  0x00, 0x1E, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1E, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x03, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1E,
  0x00, 0x00, 0x0E, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
  0x00, 0x03, 0xC0, 0x00, 0x78, 0x00, 0x00, 0x03, 0xE0, 0x00, 0xF8, 0x00, 0x00, 0x03, 0xF0, 0x01,
  0xF0, 0x00, 0x00, 0x00, 0xF9, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x7D, 0xFF, 0x80, 0x00, 0x00, 0x00,
  0x1E, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x30, 0x30, 0x2C,
  0x20, 0x30, 0x78, 0x30, 0x30, 0x2C, 0x20, 0x30,
};
const unsigned char PROGMEM all_logo [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x07, 0xBC, 0x00, 0x00, 0x1C, 0xF0, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x3F, 0xC0, 0x00,
  0x00, 0x1F, 0xDE, 0x00, 0x00, 0x3E, 0x7C, 0x00, 0x00, 0x6F, 0xF8, 0x00, 0x00, 0xFF, 0xD8, 0x00,
  0x00, 0x7F, 0xEF, 0x80, 0x00, 0xFF, 0x3F, 0x00, 0x01, 0xF7, 0xFA, 0x00, 0x00, 0xFF, 0xDE, 0x00,
  0x00, 0x3F, 0xF7, 0xC0, 0x01, 0xFF, 0x9F, 0x00, 0x03, 0xF3, 0xFB, 0x00, 0x06, 0x7F, 0xDF, 0x00,
  0x01, 0x80, 0x03, 0xE0, 0x03, 0xFF, 0xCF, 0x40, 0x07, 0xF9, 0xFB, 0x80, 0x0F, 0x3F, 0xDF, 0x80,
  0x03, 0xC0, 0x01, 0xE0, 0x00, 0x00, 0x0F, 0x60, 0x0F, 0xFE, 0xFB, 0xC0, 0x1F, 0xDF, 0xDF, 0xC0,
  0x07, 0xC0, 0x00, 0xE8, 0x0F, 0xE0, 0x03, 0x70, 0x1F, 0xFF, 0x7B, 0xE0, 0x1F, 0xCF, 0xDF, 0xE0,
  0x07, 0xC0, 0x00, 0x6C, 0x1F, 0xC0, 0x01, 0x78, 0x00, 0x00, 0x3B, 0xF0, 0x3F, 0xE7, 0xDF, 0xC0,
  0x0F, 0x80, 0x00, 0x2E, 0x1F, 0x80, 0x01, 0x7C, 0x3F, 0xC0, 0x1B, 0xF0, 0x3F, 0xFB, 0xDF, 0xA0,
  0x0E, 0x00, 0x00, 0x0E, 0x3F, 0x00, 0x00, 0x7C, 0x3F, 0xC0, 0x0B, 0xF0, 0x7F, 0xF9, 0xDF, 0x70,
  0x1C, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x7C, 0x7F, 0x80, 0x03, 0xF0, 0x7F, 0xFE, 0xDE, 0xF8,
  0x12, 0x00, 0x00, 0x0F, 0x38, 0x00, 0x00, 0x7C, 0x7F, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x1D, 0xF8,
  0x06, 0x00, 0x00, 0x0F, 0x32, 0x00, 0x00, 0x7C, 0x7C, 0x00, 0x03, 0xC8, 0x7F, 0xF0, 0x13, 0xF8,
  0x0E, 0x00, 0x00, 0x0F, 0x26, 0x00, 0x00, 0x70, 0x79, 0x00, 0x03, 0x98, 0x7F, 0xE0, 0x07, 0xF8,
  0x1E, 0x00, 0x00, 0x0F, 0x0E, 0x00, 0x00, 0x64, 0x73, 0x00, 0x03, 0x38, 0x7F, 0xC0, 0x0F, 0xF8,
  0x1E, 0x00, 0x00, 0x0E, 0x1E, 0x00, 0x00, 0x4C, 0x67, 0x00, 0x02, 0x78, 0x7F, 0xA0, 0x1F, 0xF8,
  0x1E, 0x00, 0x00, 0x08, 0x3E, 0x00, 0x00, 0x1C, 0x47, 0x00, 0x00, 0xF8, 0x7F, 0x68, 0x1F, 0xF0,
  0x1E, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x3C, 0x1F, 0x00, 0x01, 0xF8, 0x7C, 0xE8, 0x00, 0x00,
  0x1E, 0x00, 0x00, 0x0E, 0x3E, 0x00, 0x00, 0x7C, 0x3F, 0x00, 0x03, 0xF8, 0x7D, 0xED, 0xFF, 0xF8,
  0x1E, 0x00, 0x00, 0x0E, 0x1E, 0x80, 0x00, 0xF8, 0x3F, 0x40, 0x07, 0xF0, 0x3B, 0xEE, 0xFF, 0xF8,
  0x0C, 0x00, 0x00, 0x1C, 0x1E, 0xC0, 0x01, 0xF8, 0x3F, 0x60, 0x0F, 0xF0, 0x27, 0xEF, 0x7F, 0xF0,
  0x00, 0x00, 0x00, 0x38, 0x0E, 0xE0, 0x03, 0xF0, 0x1F, 0x70, 0x00, 0x00, 0x0F, 0xEF, 0xBF, 0xE0,
  0x03, 0xC0, 0x00, 0x78, 0x06, 0xF0, 0x00, 0x00, 0x1F, 0x73, 0xFF, 0xE0, 0x1F, 0xEF, 0xDF, 0xE0,
  0x03, 0xE0, 0x00, 0xF8, 0x06, 0xFB, 0xFF, 0xC0, 0x0F, 0x79, 0xFF, 0xC0, 0x0F, 0xEF, 0xEF, 0xC0,
  0x03, 0xF0, 0x01, 0xF0, 0x00, 0xF9, 0xFF, 0xC0, 0x07, 0x7C, 0xFF, 0x80, 0x07, 0xEF, 0xF7, 0x00,
  0x00, 0xF9, 0xF8, 0x00, 0x00, 0xFC, 0xFF, 0x80, 0x03, 0x7E, 0x7F, 0x00, 0x03, 0xEF, 0xFB, 0x00,
  0x00, 0x7D, 0xFF, 0x80, 0x00, 0x7E, 0x7E, 0x00, 0x00, 0x7F, 0x3C, 0x00, 0x00, 0xEF, 0xFC, 0x00,
  0x00, 0x1E, 0xFF, 0x00, 0x00, 0x1F, 0x3C, 0x00, 0x00, 0x7F, 0x98, 0x00, 0x00, 0x6F, 0xF8, 0x00,
  0x00, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x07, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x3E, 0x7E, 0x3C, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x63, 0x18, 0x66, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x63, 0x18, 0xC3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x38, 0x18, 0xC3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x06, 0x18, 0xC3, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x63, 0x18, 0xC3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x63, 0x18, 0x66, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3E, 0x18, 0x3C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void introanimation() {
  char x_axis = 48;
  char y_axis = 48;
  char X_axis = 40;
  char Y_axis = 8;
  display.drawBitmap(0 , 0, all_logo , 128 , 64 , WHITE);
  t=2;
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a1, x_axis , y_axis , WHITE);
  t=1;
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a2, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a3, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a4, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a3, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a2, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a1, x_axis , y_axis , WHITE);
  refreshtiming();
  display.drawBitmap(X_axis, Y_axis, a5, x_axis , y_axis , WHITE);
  t=2;
  refreshtiming();
  display.drawRoundRect(2, 22, 124, 28, 3, WHITE); //Show "2nd" splash screen
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(4, 26);
  display.println(F(" EXPOSURE METER v3.5 "));
  display.setCursor(7, 39);
  display.println(F("code by Kevin Agnes"));
  refreshtiming();
}



